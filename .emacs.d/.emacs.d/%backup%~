#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import matplotlib.pyplot as pl
import numpy as np
import pandas as pd
from scipy.integrate import odeint
import warnings


class Lorentz():
    """
    Integrate and salve Lorentz's oscilator

    Input
    -----

    sigma, beta, rho => Lorentz system parameters
    xi => "random" for normally distributed initial conditions
          or list w/ initial values
    t0 => starting time for the simulation
    verbose

    No Output
    ---------
    """

    NEQ = 3                     # number of equations

    # % Initialize class
    def __init__(self, sigma=10, beta=(8/3), rho=28, xi="random",
                 t0=0, verbose=False):
        super(Lorentz, self).__init__()

        self.verbose = verbose
        self.vprint = print if verbose else lambda *a, **k: None

        self.vprint("Lorentz integration")

        self.sigma = sigma
        self.beta = beta
        self.rho = rho

        self.vprint("sigma = ", self.sigma)
        self.vprint("beta = ", self.beta)
        self.vprint("rho = ", self.rho)

        # starting time of the simulation
        self.T0 = t0

        self.vprint("t0 = ", self.T0)

        if xi == "random":
            self.vprint("Random initial conditions")
            self.Xi = np.random.randn(self.NEQ)
        else:
            try:
                if len(xi) == self.NEQ:
                    self.Xi = np.asarray(xi)
                else:
                    raise IndexError("XI must have dimension = {}"
                                     .format(self.NEQ))
            except TypeError:
                raise TypeError("xi is neither a np.array nor a list")

        self.vprint("xi = ", self.Xi)

        # Control variable
        self.__Integrated = False
        return None

    # % define equations
    def equations(self, x, t):
        xprime = self.sigma * (x[1] - x[0])
        yprime = x[0] * (self.rho - x[2]) - x[1]
        zprime = x[0] * x[1] - self.beta * x[2]
        return [xprime, yprime, zprime]

    # % Integrate the equations
    def integrate(self, t_int, transient=100, step=0.01):
        """
        Integrate the Lorentz equations

        Input:
        ------
        t_int -> time of integration
        transiente -> transient time (default 100)
        step -> time step for integration (default 0.01)

        """
        t0 = self.T0
        xi = self.Xi

        self.step = step
        self.vprint("integration step = ", self.step)

        if transient > 0:
            self.t = np.arange(t0, transient, self.step)
            self.x = odeint(self.equations, xi, self.t)

            t0 = transient
            xi = self.x[-1, :]

            self.vprint(transient, "time units transient integration")

        self.t = np.arange(t0, transient+t_int, self.step)
        self.x = odeint(self.equations, xi, self.t)

        self.vprint("Integration ok, results saved at x var")
        self.__Integrated = True
        return None

    # % Plot figures
    def plot_series(self, df=None, filename=None):
        """
        plot_series: plot the time series for the Lorentz system

        Input:
        ------
        df --> (optional), dataframe with data points to be plotted on top
                           of Lorentz time series
        filename --> (optional), string wuth filename (without extension)
                                 to save the figure
        """

        # Check if system has been integrated
        if not self.__Integrated:
            warnings.warn("integrate should be called before Plotting",
                          RuntimeWarning)
            return None

        # create the figure and plot
        fig, (axx, axy, axz) = pl.subplots(nrows=3, sharex=True)

        if df is None:
            axx.plot(self.t, self.x[:, 0])
            axy.plot(self.t, self.x[:, 1])
            axz.plot(self.t, self.x[:, 2])
        else:
            axx.plot(self.t, self.x[:, 0], color="grey", linestyle=":")
            axx.plot(df["t"], df["x"], 'o')
            axy.plot(self.t, self.x[:, 1], color="grey", linestyle=":")
            axy.plot(df["t"], df["y"], 'o')
            axz.plot(self.t, self.x[:, 2], color="grey", linestyle=":")
            axz.plot(df["t"], df["z"], 'o')

        pl.setp(axx.get_xticklabels(), visible=False)
        pl.setp(axy.get_xticklabels(), visible=False)

        axx.set_ylabel("x")
        axy.set_ylabel("y")
        axz.set_ylabel("z")
        axz.set_xlabel("t")

        fig.suptitle("Lorentz time series")

        fig.show()

        if filename is not None:
            if isinstance(filename, str):
                fig.savefig(filename+".png", dpi=300)
            else:
                raise TypeError("filename should be a string")

        return None

    # % Generate Dataframe
    def GenerateDataframe(self, xstep=1, ystep=1, zstep=1, plot=False):
        """
        GenerateDataframe: generate a data frame with the time series
                           for Lorentz sampled at given time steps

        Input
        -----

        xstep, ystep, zstep -> time steps for sampling x, y and z
        plot -> (logical) if true plots time series and sampled points on top

        Output
        ------

        df, dfAll --> data frame with sampled points and dataframe with
                      the complete time series
        """

        # Check if system has been integrated
        if not self.__Integrated:
            warnings.warn("integrate should be called before " +
                          "generating DataFrame",
                          RuntimeWarning)
            return None

        df = pd.DataFrame(np.concatenate((np.asarray([self.t]).T, self.x),
                                         axis=1),
                          columns=["t", "x", "y", "z"])

        dfAll = df.copy()

        df["x"][df.index % int(xstep/self.step) != 0] = np.nan
        df["y"][df.index % int(ystep/self.step) != 0] = np.nan
        df["z"][df.index % int(zstep/self.step) != 0] = np.nan

        df = df.dropna(thresh=2).reset_index(drop=True)

        if plot:
            self.plot_series(df=df)

        return df, dfAll
